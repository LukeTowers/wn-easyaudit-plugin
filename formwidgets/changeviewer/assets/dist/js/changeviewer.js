(()=>{"use strict";var t={d:(e,i)=>{for(var n in i)t.o(i,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:i[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function i(t){if("object"!=typeof t)return t;if(null===t)return null;if(Array.isArray(t))return t.map(i);if(t instanceof Date)return new Date(t.getTime());if(t instanceof RegExp)return function(t){var e;const i=/^\/(.*)\/([gimyu]*)$/.exec(t.toString());if(!i)throw new Error("Invalid RegExp");return new RegExp(null!==(e=i[1])&&void 0!==e?e:"",i[2])}(t);const e={};for(const n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=i(t[n]));return e}function n(t,e){if(t.length<2)throw new Error(e||"Expected an array with at least 2 items")}t.r(e),t.d(e,{default:()=>q,format:()=>z,hideUnchanged:()=>B,showUnchanged:()=>H});class r{setResult(t){return this.result=t,this.hasResult=!0,this}exit(){return this.exiting=!0,this}push(t,e){var i;return t.parent=this,void 0!==e&&(t.childName=e),t.root=this.root||this,t.options=t.options||this.options,this.children?(!function(t,e){if(0===t.length)throw new Error(e||"Expected a non-empty array")}(this.children),(i=this.children,i[i.length-1]).next=t,this.children.push(t)):(this.children=[t],this.nextAfterChildren=this.next||null,this.next=t),t.next=this,this}}const o=class extends r{constructor(t,e){super(),this.left=t,this.right=e,this.pipe="diff"}prepareDeltaResult(t){var e,n,r,o;if("object"==typeof t&&((null===(e=this.options)||void 0===e?void 0:e.omitRemovedValues)&&Array.isArray(t)&&t.length>1&&(2===t.length||0===t[2]||3===t[2])&&(t[0]=0),null===(n=this.options)||void 0===n?void 0:n.cloneDiffValues)){const e="function"==typeof(null===(r=this.options)||void 0===r?void 0:r.cloneDiffValues)?null===(o=this.options)||void 0===o?void 0:o.cloneDiffValues:i;"object"==typeof t[0]&&(t[0]=e(t[0])),"object"==typeof t[1]&&(t[1]=e(t[1]))}return t}setResult(t){return this.prepareDeltaResult(t),super.setResult(t)}};const s=class extends r{constructor(t,e){super(),this.left=t,this.delta=e,this.pipe="patch"}};const l=class extends r{constructor(t){super(),this.delta=t,this.pipe="reverse"}};const f=class{constructor(t){this.name=t,this.filters=[]}process(t){if(!this.processor)throw new Error("add this pipe to a processor before using it");const e=this.debug,i=this.filters.length,n=t;for(let t=0;t<i;t++){const i=this.filters[t];if(i&&(e&&this.log(`filter: ${i.filterName}`),i(n),"object"==typeof n&&n.exiting)){n.exiting=!1;break}}!n.next&&this.resultCheck&&this.resultCheck(n)}log(t){console.log(`[jsondiffpatch] ${this.name} pipe, ${t}`)}append(...t){return this.filters.push(...t),this}prepend(...t){return this.filters.unshift(...t),this}indexOf(t){if(!t)throw new Error("a filter name is required");for(let e=0;e<this.filters.length;e++){const i=this.filters[e];if((null==i?void 0:i.filterName)===t)return e}throw new Error(`filter not found: ${t}`)}list(){return this.filters.map((t=>t.filterName))}after(t,...e){const i=this.indexOf(t);return this.filters.splice(i+1,0,...e),this}before(t,...e){const i=this.indexOf(t);return this.filters.splice(i,0,...e),this}replace(t,...e){const i=this.indexOf(t);return this.filters.splice(i,1,...e),this}remove(t){const e=this.indexOf(t);return this.filters.splice(e,1),this}clear(){return this.filters.length=0,this}shouldHaveResult(t){return!1===t?(this.resultCheck=null,this):(this.resultCheck||(this.resultCheck=t=>{if(!t.hasResult){console.log(t);const e=new Error(`${this.name} failed`);throw e.noResult=!0,e}}),this)}};const a=class{constructor(t){this.selfOptions=t||{},this.pipes={}}options(t){return t&&(this.selfOptions=t),this.selfOptions}pipe(t,e){let i=e;if("string"==typeof t){if(void 0===i)return this.pipes[t];this.pipes[t]=i}if(t&&t.name){if(i=t,i.processor===this)return i;this.pipes[i.name]=i}if(!i)throw new Error(`pipe is not defined: ${t}`);return i.processor=this,i}process(t,e){let i=t;i.options=this.options();let n,r=e||t.pipe||"default";for(;r;)void 0!==i.nextAfterChildren&&(i.next=i.nextAfterChildren,i.nextAfterChildren=null),"string"==typeof r&&(r=this.pipe(r)),r.process(i),n=r,r=null,i&&i.next&&(i=i.next,r=i.pipe||n);return i.hasResult?i.result:void 0}},c=(t,e,i,n)=>t[i]===e[n],d=(t,e,i,n)=>{const r=n||{},o=((t,e,i,n)=>{var r,o,s;const l=t.length,f=e.length;let a,c;const d=new Array(l+1);for(a=0;a<l+1;a++){const t=new Array(f+1);for(c=0;c<f+1;c++)t[c]=0;d[a]=t}for(d.match=i,a=1;a<l+1;a++){const l=d[a];if(void 0===l)throw new Error("LCS matrix row is undefined");const u=d[a-1];if(void 0===u)throw new Error("LCS matrix row is undefined");for(c=1;c<f+1;c++)i(t,e,a-1,c-1,n)?l[c]=(null!==(r=u[c-1])&&void 0!==r?r:0)+1:l[c]=Math.max(null!==(o=u[c])&&void 0!==o?o:0,null!==(s=l[c-1])&&void 0!==s?s:0)}return d})(t,e,i||c,r);return((t,e,i,n)=>{let r=e.length,o=i.length;const s={sequence:[],indices1:[],indices2:[]};for(;0!==r&&0!==o;){if(void 0===t.match)throw new Error("LCS matrix match function is undefined");if(t.match(e,i,r-1,o-1,n))s.sequence.unshift(e[r-1]),s.indices1.unshift(r-1),s.indices2.unshift(o-1),--r,--o;else{const e=t[r];if(void 0===e)throw new Error("LCS matrix row is undefined");const i=e[o-1];if(void 0===i)throw new Error("LCS matrix value is undefined");const n=t[r-1];if(void 0===n)throw new Error("LCS matrix row is undefined");const s=n[o];if(void 0===s)throw new Error("LCS matrix value is undefined");i>s?--o:--r}}return s})(o,t,e,r)};function u(t,e,i,n,r){const o=t[i],s=e[n];if(o===s)return!0;if("object"!=typeof o||"object"!=typeof s)return!1;const l=r.objectHash;if(!l)return r.matchByPosition&&i===n;r.hashCache1=r.hashCache1||[];let f=r.hashCache1[i];if(void 0===f&&(r.hashCache1[i]=f=l(o,i)),void 0===f)return!1;r.hashCache2=r.hashCache2||[];let a=r.hashCache2[n];return void 0===a&&(r.hashCache2[n]=a=l(s,n)),void 0!==a&&f===a}const h=function(t){var e,i,n,r,s;if(!t.leftIsArray)return;const l={objectHash:null===(e=t.options)||void 0===e?void 0:e.objectHash,matchByPosition:null===(i=t.options)||void 0===i?void 0:i.matchByPosition};let f,a,c,h=0,p=0;const v=t.left,m=t.right,g=v.length,y=m.length;let x,w;for(g>0&&y>0&&!l.objectHash&&"boolean"!=typeof l.matchByPosition&&(l.matchByPosition=!function(t,e,i,n){for(let r=0;r<i;r++){const i=t[r];for(let t=0;t<n;t++){const n=e[t];if(r!==t&&i===n)return!0}}return!1}(v,m,g,y));h<g&&h<y&&u(v,m,h,h,l);)f=h,x=new o(v[f],m[f]),t.push(x,f),h++;for(;p+h<g&&p+h<y&&u(v,m,g-1-p,y-1-p,l);)a=g-1-p,c=y-1-p,x=new o(v[a],m[c]),t.push(x,c),p++;if(h+p===g){if(g===y)return void t.setResult(void 0).exit();for(w=w||{_t:"a"},f=h;f<y-p;f++)w[f]=[m[f]],t.prepareDeltaResult(w[f]);return void t.setResult(w).exit()}if(h+p===y){for(w=w||{_t:"a"},f=h;f<g-p;f++){const e=`_${f}`;w[e]=[v[f],0,0],t.prepareDeltaResult(w[e])}return void t.setResult(w).exit()}l.hashCache1=void 0,l.hashCache2=void 0;const b=v.slice(h,g-p),j=m.slice(h,y-p),$=d(b,j,u,l),R=[];for(w=w||{_t:"a"},f=h;f<g-p;f++)if($.indices1.indexOf(f-h)<0){const e=`_${f}`;w[e]=[v[f],0,0],t.prepareDeltaResult(w[e]),R.push(f)}let A=!0;(null===(n=t.options)||void 0===n?void 0:n.arrays)&&!1===t.options.arrays.detectMove&&(A=!1);let _=!1;(null===(s=null===(r=t.options)||void 0===r?void 0:r.arrays)||void 0===s?void 0:s.includeValueOnMove)&&(_=!0);const N=R.length;for(f=h;f<y-p;f++){const e=$.indices2.indexOf(f-h);if(e<0){let e=!1;if(A&&N>0)for(let i=0;i<N;i++){a=R[i];const n=void 0===a?void 0:w[`_${a}`];if(void 0!==a&&n&&u(b,j,a-h,f-h,l)){n.splice(1,2,f,3),n.splice(1,2,f,3),_||(n[0]=""),c=f,x=new o(v[a],m[c]),t.push(x,c),R.splice(i,1),e=!0;break}}e||(w[f]=[m[f]],t.prepareDeltaResult(w[f]))}else{if(void 0===$.indices1[e])throw new Error(`Invalid indexOnArray2: ${e}, seq.indices1: ${$.indices1}`);if(a=$.indices1[e]+h,void 0===$.indices2[e])throw new Error(`Invalid indexOnArray2: ${e}, seq.indices2: ${$.indices2}`);c=$.indices2[e]+h,x=new o(v[a],m[c]),t.push(x,c)}}t.setResult(w).exit()};h.filterName="arrays";const p={numerically:(t,e)=>t-e,numericallyBy:t=>(e,i)=>e[t]-i[t]},v=function(t){var e;if(!t.nested)return;const i=t.delta;if("a"!==i._t)return;let n,r;const o=i,l=t.left;let f=[],a=[];const c=[];for(n in o)if("_t"!==n)if("_"===n[0]){const t=n;if(void 0===o[t]||0!==o[t][2]&&3!==o[t][2])throw new Error(`only removal or move can be applied at original array indices, invalid diff type: ${null===(e=o[t])||void 0===e?void 0:e[2]}`);f.push(Number.parseInt(n.slice(1),10))}else{const t=n;1===o[t].length?a.push({index:Number.parseInt(t,10),value:o[t][0]}):c.push({index:Number.parseInt(t,10),delta:o[t]})}for(f=f.sort(p.numerically),n=f.length-1;n>=0;n--){if(r=f[n],void 0===r)continue;const t=o[`_${r}`],e=l.splice(r,1)[0];3===(null==t?void 0:t[2])&&a.push({index:t[1],value:e})}a=a.sort(p.numericallyBy("index"));const d=a.length;for(n=0;n<d;n++){const t=a[n];void 0!==t&&l.splice(t.index,0,t.value)}const u=c.length;if(u>0)for(n=0;n<u;n++){const e=c[n];if(void 0===e)continue;const i=new s(l[e.index],e.delta);t.push(i,e.index)}t.children?t.exit():t.setResult(l).exit()};v.filterName="arrays";const m=function(t){if(!t||!t.children)return;if("a"!==t.delta._t)return;const e=t.left,i=t.children.length;for(let n=0;n<i;n++){const i=t.children[n];if(void 0===i)continue;e[i.childName]=i.result}t.setResult(e).exit()};m.filterName="arraysCollectChildren";const g=function(t){if(!t.nested){const e=t.delta;if(3===e[2]){const i=e;t.newName=`_${i[1]}`,t.setResult([i[0],Number.parseInt(t.childName.substring(1),10),3]).exit()}return}const e=t.delta;if("a"!==e._t)return;const i=e;for(const e in i){if("_t"===e)continue;const n=new l(i[e]);t.push(n,e)}t.exit()};g.filterName="arrays";const y=(t,e,i)=>{if("string"==typeof e&&"_"===e[0])return Number.parseInt(e.substring(1),10);if(Array.isArray(i)&&0===i[2])return`_${e}`;let n=+e;for(const i in t){const r=t[i];if(Array.isArray(r))if(3===r[2]){const t=Number.parseInt(i.substring(1),10),o=r[1];if(o===+e)return t;t<=n&&o>n?n++:t>=n&&o<n&&n--}else if(0===r[2]){Number.parseInt(i.substring(1),10)<=n&&n++}else 1===r.length&&Number.parseInt(i,10)<=n&&n--}return n},x=t=>{if(!t||!t.children)return;const e=t.delta;if("a"!==e._t)return;const i=e,n=t.children.length,r={_t:"a"};for(let e=0;e<n;e++){const n=t.children[e];if(void 0===n)continue;let o=n.newName;if(void 0===o){if(void 0===n.childName)throw new Error("child.childName is undefined");o=y(i,n.childName,n.result)}r[o]!==n.result&&(r[o]=n.result)}t.setResult(r).exit()};x.filterName="arraysCollectChildren";const w=function(t){t.left instanceof Date?(t.right instanceof Date?t.left.getTime()!==t.right.getTime()?t.setResult([t.left,t.right]):t.setResult(void 0):t.setResult([t.left,t.right]),t.exit()):t.right instanceof Date&&t.setResult([t.left,t.right]).exit()};w.filterName="dates";const b=t=>{if(!t||!t.children)return;const e=t.children.length;let i=t.result;for(let n=0;n<e;n++){const e=t.children[n];if(void 0!==e&&void 0!==e.result){if(i=i||{},void 0===e.childName)throw new Error("diff child.childName is undefined");i[e.childName]=e.result}}i&&t.leftIsArray&&(i._t="a"),t.setResult(i).exit()};b.filterName="collectChildren";const j=t=>{var e;if(t.leftIsArray||"object"!==t.leftType)return;const i=t.left,n=t.right,r=null===(e=t.options)||void 0===e?void 0:e.propertyFilter;for(const e in i){if(!Object.prototype.hasOwnProperty.call(i,e))continue;if(r&&!r(e,t))continue;const s=new o(i[e],n[e]);t.push(s,e)}for(const e in n)if(Object.prototype.hasOwnProperty.call(n,e)&&(!r||r(e,t))&&void 0===i[e]){const i=new o(void 0,n[e]);t.push(i,e)}t.children&&0!==t.children.length?t.exit():t.setResult(void 0).exit()};j.filterName="objects";const $=function(t){if(!t.nested)return;const e=t.delta;if(e._t)return;const i=e;for(const e in i){const n=new s(t.left[e],i[e]);t.push(n,e)}t.exit()};$.filterName="objects";const R=function(t){if(!t||!t.children)return;if(t.delta._t)return;const e=t.left,i=t.children.length;for(let n=0;n<i;n++){const i=t.children[n];if(void 0===i)continue;const r=i.childName;Object.prototype.hasOwnProperty.call(t.left,r)&&void 0===i.result?delete e[r]:e[r]!==i.result&&(e[r]=i.result)}t.setResult(e).exit()};R.filterName="collectChildren";const A=function(t){if(!t.nested)return;if(t.delta._t)return;const e=t.delta;for(const i in e){const n=new l(e[i]);t.push(n,i)}t.exit()};A.filterName="objects";const _=t=>{if(!t||!t.children)return;if(t.delta._t)return;const e=t.children.length,i={};for(let n=0;n<e;n++){const e=t.children[n];if(void 0===e)continue;const r=e.childName;i[r]!==e.result&&(i[r]=e.result)}t.setResult(i).exit()};_.filterName="collectChildren";let N=null;function E(t,e){var i;if(!N){let n;if(!(null===(i=null==t?void 0:t.textDiff)||void 0===i?void 0:i.diffMatchPatch)){if(!e)return null;const t=new Error("The diff-match-patch library was not provided. Pass the library in through the options or use the `jsondiffpatch/with-text-diffs` entry-point.");throw t.diff_match_patch_not_found=!0,t}n=new t.textDiff.diffMatchPatch,N={diff:(t,e)=>n.patch_toText(n.patch_make(t,e)),patch:(t,e)=>{const i=n.patch_apply(n.patch_fromText(e),t);for(const t of i[1])if(!t){const t=new Error("text patch failed");throw t.textPatchFailed=!0,t}return i[0]}}}return N}const C=function(t){var e,i;if("string"!==t.leftType)return;const n=t.left,r=t.right,o=(null===(i=null===(e=t.options)||void 0===e?void 0:e.textDiff)||void 0===i?void 0:i.minLength)||60;if(n.length<o||r.length<o)return void t.setResult([n,r]).exit();const s=E(t.options);if(!s)return void t.setResult([n,r]).exit();const l=s.diff;t.setResult([l(n,r),0,2]).exit()};C.filterName="texts";const O=function(t){if(t.nested)return;const e=t.delta;if(2!==e[2])return;const i=e,n=E(t.options,!0).patch;t.setResult(n(t.left,i[0])).exit()};O.filterName="texts";const T=t=>{var e,i,n;const r=/^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/,o=t.split("\n");for(let t=0;t<o.length;t++){const s=o[t];if(void 0===s)continue;const l=s.slice(0,1);if("@"===l){const e=r.exec(s);if(null!==e){o[t]=`@@ -${e[3]},${e[4]} +${e[1]},${e[2]} @@`}}else if("+"===l){if(o[t]=`-${null===(e=o[t])||void 0===e?void 0:e.slice(1)}`,"+"===(null===(i=o[t-1])||void 0===i?void 0:i.slice(0,1))){const e=o[t];o[t]=o[t-1],o[t-1]=e}}else"-"===l&&(o[t]=`+${null===(n=o[t])||void 0===n?void 0:n.slice(1)}`)}return o.join("\n")},k=function(t){if(t.nested)return;const e=t.delta;if(2!==e[2])return;const i=e;t.setResult([T(i[0]),0,2]).exit()};k.filterName="texts";const D=function(t){if(t.left!==t.right)if(void 0!==t.left)if(void 0!==t.right){if("function"==typeof t.left||"function"==typeof t.right)throw new Error("functions are not supported");t.leftType=null===t.left?"null":typeof t.left,t.rightType=null===t.right?"null":typeof t.right,t.leftType===t.rightType&&"boolean"!==t.leftType&&"number"!==t.leftType?("object"===t.leftType&&(t.leftIsArray=Array.isArray(t.left)),"object"===t.rightType&&(t.rightIsArray=Array.isArray(t.right)),t.leftIsArray===t.rightIsArray?t.left instanceof RegExp&&(t.right instanceof RegExp?t.setResult([t.left.toString(),t.right.toString()]).exit():t.setResult([t.left,t.right]).exit()):t.setResult([t.left,t.right]).exit()):t.setResult([t.left,t.right]).exit()}else t.setResult([t.left,0,0]).exit();else{if("function"==typeof t.right)throw new Error("functions are not supported");t.setResult([t.right]).exit()}else t.setResult(void 0).exit()};D.filterName="trivial";const S=function(t){if(void 0===t.delta)return void t.setResult(t.left).exit();if(t.nested=!Array.isArray(t.delta),t.nested)return;const e=t.delta;if(1!==e.length)if(2!==e.length)3===e.length&&0===e[2]&&t.setResult(void 0).exit();else{if(t.left instanceof RegExp){const i=/^\/(.*)\/([gimyu]+)$/.exec(e[1]);if(null==i?void 0:i[1])return void t.setResult(new RegExp(i[1],i[2])).exit()}t.setResult(e[1]).exit()}else t.setResult(e[0]).exit()};S.filterName="trivial";const I=function(t){if(void 0===t.delta)return void t.setResult(t.delta).exit();if(t.nested=!Array.isArray(t.delta),t.nested)return;const e=t.delta;1!==e.length?2!==e.length?3===e.length&&0===e[2]&&t.setResult([e[0]]).exit():t.setResult([e[1],e[0]]).exit():t.setResult([e[0],0,0]).exit()};I.filterName="trivial";const M=class{constructor(t){this.processor=new a(t),this.processor.pipe(new f("diff").append(b,D,w,C,j,h).shouldHaveResult()),this.processor.pipe(new f("patch").append(R,m,S,O,$,v).shouldHaveResult()),this.processor.pipe(new f("reverse").append(_,x,I,k,A,g).shouldHaveResult())}options(t){return this.processor.options(t)}diff(t,e){return this.processor.process(new o(t,e))}patch(t,e){return this.processor.process(new s(t,e))}reverse(t){return this.processor.process(new l(t))}unpatch(t,e){return this.patch(t,this.reverse(e))}clone(t){return i(t)}};const P=class{format(t,e){const i={};this.prepareContext(i);const n=i;return this.recurse(n,t,e),this.finalize(n)}prepareContext(t){t.buffer=[],t.out=function(...t){if(!this.buffer)throw new Error("context buffer is not initialized");this.buffer.push(...t)}}typeFormattterNotFound(t,e){throw new Error(`cannot format delta type: ${e}`)}typeFormattterErrorFormatter(t,e,i,n,r,o,s){}finalize({buffer:t}){return Array.isArray(t)?t.join(""):""}recurse(t,e,i,n,r,o,s){const l=e&&o?o.value:i;if(void 0===e&&void 0===n)return;const f=this.getDeltaType(e,o),a="node"===f?"a"===e._t?"array":"object":"";let c;void 0!==n?this.nodeBegin(t,n,r,f,a,null!=s&&s):this.rootBegin(t,f,a);try{c="unknown"!==f?this[`format_${f}`]:this.typeFormattterNotFound(t,f),c.call(this,t,e,l,n,r,o)}catch(i){this.typeFormattterErrorFormatter(t,i,e,l,n,r,o),"undefined"!=typeof console&&console.error&&console.error(i.stack)}void 0!==n?this.nodeEnd(t,n,r,f,a,null!=s&&s):this.rootEnd(t,f,a)}formatDeltaChildren(t,e,i){this.forEachDeltaKey(e,i,((n,r,o,s)=>{this.recurse(t,e[n],i?i[r]:void 0,n,r,o,s)}))}forEachDeltaKey(t,e,i){const n=[];if(!("a"===t._t)){const r=Object.keys(t);"object"==typeof e&&null!==e&&n.push(...Object.keys(e));for(const t of r)n.indexOf(t)>=0||n.push(t);for(let t=0;t<n.length;t++){const e=n[t];if(void 0===e)continue;const r=t===n.length-1;i(e,e,void 0,r)}return}const r={};for(const e in t)if(Object.prototype.hasOwnProperty.call(t,e)){const i=t[e];if(Array.isArray(i)&&3===i[2]){r[i[1]]=Number.parseInt(e.substring(1))}}const o=t;let s=0,l=0;const f=Array.isArray(e)?e:void 0,a=f?f.length:Object.keys(o).reduce(((t,e)=>{if("_t"===e)return t;if("_"===e.substring(0,1)){const i=o[e],n=Number.parseInt(e.substring(1)),r=Array.isArray(i)&&i.length>=3&&3===i[2]?i[1]:void 0,s=Math.max(n,null!=r?r:0);return s>t?s:t}const i=Number.parseInt(e),n=r[i],s=Math.max(null!=n?n:0,null!=i?i:0);return s>t?s:t}),0)+1;let c,d=a;const u=(...t)=>{c&&i(...c),c=t};for(;s<a||l<d||`${l}`in o;){let t=!1;const e=`_${s}`,i=`${l}`,n=l in r?r[l]:void 0;if(e in o){t=!0;const i=o[e];u(e,null!=n?n:s,n?{key:`_${n}`,value:f?f[n]:void 0}:void 0,!1),Array.isArray(i)?0===i[2]?(d--,s++):(i[2],s++):s++}if(i in o){t=!0;const e=o[i],r=Array.isArray(e)&&1===e.length;u(i,null!=n?n:s,n?{key:`_${n}`,value:f?f[n]:void 0}:void 0,!1),r?(d++,l++):void 0===n?(s++,l++):l++}t||((f&&void 0===n||!1!==this.includeMoveDestinations)&&u(i,null!=n?n:s,n?{key:`_${n}`,value:f?f[n]:void 0}:void 0,!1),void 0!==n||s++,l++)}c&&i(c[0],c[1],c[2],!0)}getDeltaType(t,e){if(void 0===t)return void 0!==e?"movedestination":"unchanged";if(Array.isArray(t)){if(1===t.length)return"added";if(2===t.length)return"modified";if(3===t.length&&0===t[2])return"deleted";if(3===t.length&&2===t[2])return"textdiff";if(3===t.length&&3===t[2])return"moved"}else if("object"==typeof t)return"node";return"unknown"}parseTextDiff(t){var e;const i=[],r=t.split("\n@@ ");for(const t of r){const r={pieces:[]},o=null===(e=/^(?:@@ )?[-+]?(\d+),(\d+)/.exec(t))||void 0===e?void 0:e.slice(1);if(!o)throw new Error("invalid text diff format");n(o),r.location={line:o[0],chr:o[1]};const s=t.split("\n").slice(1);for(let t=0,e=s.length;t<e;t++){const e=s[t];if(void 0===e||!e.length)continue;const i={type:"context"};"+"===e.substring(0,1)?i.type="added":"-"===e.substring(0,1)&&(i.type="deleted"),i.text=e.slice(1),r.pieces.push(i)}i.push(r)}return i}};class L extends P{typeFormattterErrorFormatter(t,e){const i="object"==typeof e&&null!==e&&"message"in e&&"string"==typeof e.message?e.message:String(e);t.out(`<pre class="jsondiffpatch-error">${V(i)}</pre>`)}formatValue(t,e){const i=void 0===e?"undefined":V(JSON.stringify(e,null,2));t.out(`<pre>${i}</pre>`)}formatTextDiffString(t,e){const i=this.parseTextDiff(e);t.out('<ul class="jsondiffpatch-textdiff">');for(let e=0,n=i.length;e<n;e++){const n=i[e];if(void 0===n)return;t.out(`<li><div class="jsondiffpatch-textdiff-location"><span class="jsondiffpatch-textdiff-line-number">${n.location.line}</span><span class="jsondiffpatch-textdiff-char">${n.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`);const r=n.pieces;for(let e=0,i=r.length;e<i;e++){const i=r[e];if(void 0===i)return;t.out(`<span class="jsondiffpatch-textdiff-${i.type}">${V(decodeURI(i.text))}</span>`)}t.out("</div></li>")}t.out("</ul>")}rootBegin(t,e,i){const n=`jsondiffpatch-${e}${i?` jsondiffpatch-child-node-type-${i}`:""}`;t.out(`<div class="jsondiffpatch-delta ${n}">`)}rootEnd(t){t.out("</div>"+(t.hasArrows?`<script type="text/javascript">setTimeout(${F.toString()},10);<\/script>`:""))}nodeBegin(t,e,i,n,r){const o=`jsondiffpatch-${n}${r?` jsondiffpatch-child-node-type-${r}`:""}`,s="number"==typeof i&&"_"===e.substring(0,1)?e.substring(1):e;t.out(`<li class="${o}" data-key="${V(e)}"><div class="jsondiffpatch-property-name">${V(s)}</div>`)}nodeEnd(t){t.out("</li>")}format_unchanged(t,e,i){void 0!==i&&(t.out('<div class="jsondiffpatch-value">'),this.formatValue(t,i),t.out("</div>"))}format_movedestination(t,e,i){void 0!==i&&(t.out('<div class="jsondiffpatch-value">'),this.formatValue(t,i),t.out("</div>"))}format_node(t,e,i){const n="a"===e._t?"array":"object";t.out(`<ul class="jsondiffpatch-node jsondiffpatch-node-type-${n}">`),this.formatDeltaChildren(t,e,i),t.out("</ul>")}format_added(t,e){t.out('<div class="jsondiffpatch-value">'),this.formatValue(t,e[0]),t.out("</div>")}format_modified(t,e){t.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">'),this.formatValue(t,e[0]),t.out('</div><div class="jsondiffpatch-value jsondiffpatch-right-value">'),this.formatValue(t,e[1]),t.out("</div>")}format_deleted(t,e){t.out('<div class="jsondiffpatch-value">'),this.formatValue(t,e[0]),t.out("</div>")}format_moved(t,e){t.out('<div class="jsondiffpatch-value">'),this.formatValue(t,e[0]),t.out(`</div><div class="jsondiffpatch-moved-destination">${e[1]}</div>`),t.out('<div class="jsondiffpatch-arrow" style="position: relative; left: -34px;">\n          <svg width="30" height="60" style="position: absolute; display: none;">\n          <defs>\n              <marker id="markerArrow" markerWidth="8" markerHeight="8"\n                 refx="2" refy="4" stroke="#88f"\n                     orient="auto" markerUnits="userSpaceOnUse">\n                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\n              </marker>\n          </defs>\n          <path d="M30,0 Q-10,25 26,50"\n            style="stroke: #88f; stroke-width: 2px; fill: none; stroke-opacity: 0.5; marker-end: url(#markerArrow);"\n          ></path>\n          </svg>\n      </div>'),t.hasArrows=!0}format_textdiff(t,e){t.out('<div class="jsondiffpatch-value">'),this.formatTextDiffString(t,e[0]),t.out("</div>")}}function V(t){if("number"==typeof t)return t;let e=String(t);const i=[[/&/g,"&amp;"],[/</g,"&lt;"],[/>/g,"&gt;"],[/'/g,"&apos;"],[/"/g,"&quot;"]];for(const t of i)e=e.replace(t[0],t[1]);return e}const F=function(t){const e=t||document;((t,e,i)=>{const n=t.querySelectorAll(e);for(let t=0,e=n.length;t<e;t++)i(n[t])})(e,".jsondiffpatch-arrow",(({parentNode:t,children:e,style:i})=>{const n=t,r=e[0],o=r.children[1];r.style.display="none";const s=n.querySelector(".jsondiffpatch-moved-destination");if(!(s instanceof HTMLElement))return;const l=(({textContent:t,innerText:e})=>t||e)(s),f=n.parentNode;if(!f)return;let a;if((({children:t},e)=>{for(let i=0,n=t.length;i<n;i++){const n=t[i];n&&e(n,i)}})(f,(t=>{t.getAttribute("data-key")===l&&(a=t)})),a)try{const t=a.offsetTop-n.offsetTop;r.setAttribute("height",`${Math.abs(t)+6}`),i.top=`${-8+(t>0?0:t)}px`;const e=t>0?`M30,0 Q-10,${Math.round(t/2)} 26,${t-4}`:`M30,${-t} Q-10,${Math.round(-t/2)} 26,4`;o.setAttribute("d",e),r.style.display=""}catch(t){console.debug(`[jsondiffpatch] error adjusting arrows: ${t}`)}}))},H=(t,e,i)=>{const n=e||document.body,r="jsondiffpatch-unchanged-",o={showing:`${r}showing`,hiding:`${r}hiding`,visible:`${r}visible`,hidden:`${r}hidden`},s=n.classList;if(!s)return;if(!i)return s.remove(o.showing),s.remove(o.hiding),s.remove(o.visible),s.remove(o.hidden),void(!1===t&&s.add(o.hidden));!1===t?(s.remove(o.showing),s.add(o.visible),setTimeout((()=>{s.add(o.hiding)}),10)):(s.remove(o.hiding),s.add(o.showing),s.remove(o.hidden));const l=setInterval((()=>{F(n)}),100);setTimeout((()=>{s.remove(o.showing),s.remove(o.hiding),!1===t?(s.add(o.hidden),s.remove(o.visible)):(s.add(o.visible),s.remove(o.hidden)),setTimeout((()=>{s.remove(o.visible),clearInterval(l)}),i+400)}),i)},B=(t,e)=>H(!1,t,e),q=L;let U;function z(t,e){return U||(U=new L),U.format(t,e)}window.jsondiffpatch=new M({objectHash:function(t){return JSON.stringify(t)},arrays:{detectMove:!0,includeValueOnMove:!0},textDiff:{minLength:1}}),window.jsondiffpatchHtml=e})();